\documentclass[book, nodocumentinfo]{upmethodology-document}

%% The TeX code is entering with UTF8
%% character encoding (Linux and MacOS standards)
\usepackage[utf8]{inputenc}
%% For algorithms
\usepackage[chapter]{algorithm}
\usepackage{algpseudocode}
%% For bibtex
\usepackage{natbib}

\setfrontcover{classic}

\declaredocument{Report about Radix Sort LO27 Project}{Report about Radix Sort LO27 Project for the UTBM}{LO27-A2015}
\setpublisher{University of Technology of Belfort-Montbéliard}

\incversion{\makedate{7}{11}{2015}}{Initial version.}{\upmpublic}

\addauthorvalidator*[benoit.cortier@utbm.fr]{Benoît}{CORTIER}{Author}
\addauthorvalidator*[jerome.boulmier@utbm.fr]{Jérôme}{BOULMIER}{Author}

\setdockeywords{\LaTeX, Radix Sort, Sorting, Algorithm, LO27, Programming}

\setdocabstract{}

\makeatletter
\let\VERversion\upm@package@version@ver
\let\VERfmt\upm@package@fmt@ver
\let\VERdoc\upm@package@doc@ver
\let\VERfp\upm@package@fp@ver
\let\VERbp\upm@package@bp@ver
\let\VERext\upm@package@ext@ver
\let\VERtask\upm@package@task@ver
\let\VERdocclazz\upm@package@docclazz@ver
\let\VERcode\upm@package@code@ver
\makeatother

\setcopyrighter{Benoît CORTIER \& Jérôme BOULMIER}
\setprintingaddress{France}

% Espace insécable (le caractère ~ se traduit par un espace insécable).
\DeclareUnicodeCharacter{00A0}{~}
% Sur un clavier bépo, on a un accès direct au ×
\DeclareUnicodeCharacter{00D7}{\times}

\begin{document}

\chapter{Introduction}

…

\tableofcontents

\listofalgorithms

\chapter{Objectives and problem statements}

…

\chapter{Data structures}

…

\section{BaseNIntegerList}

The type \emph{BaseNIntegerList} represents a list of base-N integers.
This list will be implemented using a doubly linked-list.

\begin{table}[h]
    \centering
    \label{tab:basenintegerlist-struct}

    \begin{tabular}{|l|c|}
        \hline
        BaseNIntegerElement* & head \\
        \hline
        BaseNIntegerElement* & tail \\
        \hline
        int & base \\
        \hline
        int & size \\
        \hline
    \end{tabular}

    \caption{BaseNIntegerList structure}
\end{table}

\begin{itemize}
    \item \emph{head}: pointer to the first element of the list.
    \item \emph{tail}: pointer to the last element of the list.
    \item \emph{base}: an integer between 2 and 16.
    \item \emph{size}: the current number of elements in the list.
\end{itemize}

\subsection{BaseNIntegerElement}

\begin{table}[h]
    \centering
    \label{tab:basenintegerelement-struct}

    \begin{tabular}{|l|c|}
        \hline
        BaseNIntegerElement* & prev \\
        \hline
        BaseNIntegerElement* & next \\
        \hline
        char* & value \\
        \hline
    \end{tabular}

    \caption{BaseNIntegerElement structure}
\end{table}

\section{BaseNIntegerListOfList}

…

\chapter{Algorithms}

…

\section{BaseNIntegerList}

\emph{createIntegerList}: \emph{Integer} \(\rightarrow\) \emph{BaseNIntegerList},
    create a new empty \emph{BaseNIntegerList} for storing integers in the specified base.
    \ref{algo:basenintegerlist-create-integer-list} is the corresponding algorithm.

\begin{algorithm}[H]
    \label{algo:basenintegerlist-create-integer-list}
    \caption{createIntegerList algorithm}

    \begin{algorithmic}
        \Function{createIntegerList}{base : Integer} : BaseNIntegerList
            \State \(l \leftarrow\) create(BaseNIntegerList)
            \State head(\(l\)) \(\leftarrow\) undefined
            \State tail(\(l\)) \(\leftarrow\) undefined
            \State base(\(l\)) \(\leftarrow\) base
            \State size(\(l\)) \(\leftarrow 0\)
            \State createIntegerList \(\leftarrow l\)
        \EndFunction
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{isEmpty}: \emph{BaseNIntegerList} \(\rightarrow\) \emph{Boolean},
returns true if the specified list is empty, false otherwise.
\ref{algo:basenintegerlist-is-empty} is the corresponding algorithm.

\begin{algorithm}[H]
    \label{algo:basenintegerlist-is-empty}
    \caption{isEmpty algorithm}

    \begin{algorithmic}
        \Function{isEmpty}{\(l\) : BaseNIntegerList} : Boolean
            \If{head(\(l\)) = undefined}
                \State isEmpty \(\leftarrow\) TRUE
            \Else
                \State isEmpty \(\leftarrow\) FALSE
            \EndIf
        \EndFunction
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{insertHead}: \emph{BaseNIntegerList} \(\times\) \emph{char*} \(\rightarrow\) \emph{BaseNIntegerList},
adds the specified integer (\emph{char*}, represented in the considered base) at the beginning
of the specified list.
\ref{algo:basenintegerlist-insert-head} is the corresponding algorithm.

\emph{Principle}
\begin{itemize}
    \item create a new element.
    \item link it and the rest of the list to each other if any.
    \item make it the head of the list.
    \item increase size of the list accordingly.
\end{itemize}

\begin{algorithm}[H]
    \label{algo:basenintegerlist-insert-head}
    \caption{insertHead algorithm}

    \begin{algorithmic}
        \Function{insertHead}{\(l\) : BaseNIntegerList, value : char*} : BaseNIntegerList
            \State new\_el \(\leftarrow\) create(BaseNIntegerElement)

            \State value(new\_el) \(\leftarrow\) value
            \State prev(new\_el) \(\leftarrow\) undefined

            \If{isEmpty(\(l\))}
                \State next(new\_el) \(\leftarrow\) undefined
                \State tail(\(l\)) \(\leftarrow\) new\_el
            \Else
                \State next(new\_el) \(\leftarrow\) head(\(l\))
                \State prev(head(\(l\))) \(\leftarrow\) new\_el
            \EndIf

            \State head(\(l\)) \(\leftarrow\) new\_el
            \State size(\(l\)) \(\leftarrow\) size(\(l\)) + 1

            \State insertHead \(\leftarrow l\)
        \EndFunction
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{insertTail}: \emph{BaseNIntegerList} \(\times\) \emph{char*} \(\rightarrow\) \emph{BaseNIntegerList},
adds the specified integer (\emph{char*}, represented in the considered base) at the end
of the specified list.
\ref{algo:basenintegerlist-insert-tail} is the corresponding algorithm.

\emph{Principle}
\begin{itemize}
    \item create a new element.
    \item link it and the tail of the list to each other if any.
    \item make it the tail of the list.
    \item increase size of the list accordingly.
\end{itemize}

\begin{algorithm}[H]
    \label{algo:basenintegerlist-insert-tail}
    \caption{insertTail algorithm}

    \begin{algorithmic}
        \Function{insertTail}{\(l\) : BaseNIntegerList, value : char*} : BaseNIntegerList
            \State new\_el \(\leftarrow\) create(BaseNIntegerElement)

            \State value(new\_el) \(\leftarrow\) value
            \State next(new\_el) \(\leftarrow\) undefined

            \If{isEmpty(\(l\))}
                \State prev(new\_el) \(\leftarrow\) undefined
                \State head(\(l\)) \(\leftarrow\) new\_el
            \Else
                \State prev(new\_el) \(\leftarrow\) tail(\(l\))
                \State next(tail(\(l\))) \(\leftarrow\) new\_el
            \EndIf

            \State tail(\(l\)) \(\leftarrow\) new\_el
            \State size(\(l\)) \(\leftarrow\) size(\(l\)) + 1

            \State insertTail \(\leftarrow l\)
        \EndFunction
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{removeHead}: \emph{BaseNIntegerList} \(\rightarrow\) \emph{BaseNIntegerList},
removes the first element of the specified list.
\ref{algo:basenintegerlist-remove-head} is the corresponding algorithm.

\emph{Principle}
\begin{itemize}
    \item makes the second element the head of the list if any.
    \item free the first element from the memory.
    \item decrease size of the list accordingly.
\end{itemize}

\begin{algorithm}[H]
    \label{algo:basenintegerlist-remove-head}
    \caption{removeHead algorithm}

    \begin{algorithmic}
        \Function{removeHead}{\(l\) : BaseNIntegerList} : BaseNIntegerList
            \If{isEmpty(l)}
                \State removeHead \(\leftarrow l\)
            \EndIf

            \State BaseNIntegerElement old\_el \(\leftarrow\) head(l)
            \State head(l) \(\leftarrow\) next(head(l))
            \State free(old\_el)
            \State size(\(l\)) \(\leftarrow\) size(\(l\)) - 1

            \If{isEmpty(l)}
                \State tail(l) \(\leftarrow\) undefined
            \Else
                \State prev(head(l)) \(\leftarrow\) undefined
            \EndIf

            \State removeHead \(\leftarrow l\)
        \EndFunction
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{removeTail}: \emph{BaseNIntegerList} \(\rightarrow\) \emph{BaseNIntegerList},
removes the last element of the specified list.
\ref{algo:basenintegerlist-remove-tail} is the corresponding algorithm.

\emph{Principle}
\begin{itemize}
    \item makes element n-1 the tail of the list if n \(>\) 1.
    \item free element n from the memory.
    \item decrease size of the list accordingly.
\end{itemize}

\begin{algorithm}[H]
    \label{algo:basenintegerlist-remove-tail}
    \caption{removeTail algorithm}

    \begin{algorithmic}
        \Function{removeTail}{\(l\) : BaseNIntegerList} : BaseNIntegerList
            \If{isEmpty(l)}
                \State removeTail \(\leftarrow l\)
            \EndIf

            \State BaseNIntegerElement old\_el \(\leftarrow\) tail(l)
            \State tail(l) \(\leftarrow\) prev(tail(l))
            \State free(old\_el)
            \State size(\(l\)) \(\leftarrow\) size(\(l\)) - 1

            \If{tail(l) = undefined}
                \State head(l) \(\leftarrow\) undefined
            \Else
                \State next(tail(l)) \(\leftarrow\) undefined
            \EndIf

            \State removeTail \(\leftarrow l\)
        \EndFunction
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{deleteIntegerList}: \emph{BaseNIntegerList} \(\rightarrow\) \(\emptyset\),
clears and deletes the specified BaseNIntegerList.
\ref{algo:basenintegerlist-delete-integer-list} is the corresponding algorithm.

\emph{Principle}: traverse the entire list and free each element.

\begin{algorithm}[H]
    \label{algo:basenintegerlist-delete-integer-list}
    \caption{deleteIntegerList algorithm}

    \begin{algorithmic}
        \Function{deleteIntegerList}{\(l\) : BaseNIntegerList} : \(\emptyset\)
            \If{!isEmpty(l)}
                \State BaseNIntegerElement old\_el \(\leftarrow\) head(l)
                \State BaseNIntegerElement next\_el

                \While{next(old\_el) \(\neq\) undefined}
                    \State next\_el \(\leftarrow\) next(old\_el)
                    \State free(old\_el)
                    \State old\_el \(\leftarrow\) next\_el
                \EndWhile

                \State free(old\_el)
            \EndIf
        \EndFunction
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{baseNToDecimal}: \emph{char* x Integer} \(\rightarrow\) \emph{Integer},
converts the specified integer (char*) represented with the specified base (Integer, second parameter) into a corresponding integer in base 10.
\ref{algo:basenintegerlist-base-to-decimal} is the corresponding algorithm.

\emph{Principle}
\begin{itemize}
    \item Compute \(\sum\limits_{i=0}^{N - 1}{d_i \times K^i}\), where K is the base and \(d_i)\) the digit in position i.
\end{itemize}

\begin{algorithm}[H]
    \label{algo:basenintegerlist-base-to-decimal}
    \caption{baseNToDecimal algorithm}

    \begin{algorithmic}
        \Function{baseNToDecimal}{n : char*, base : integer} : integer
            \State number \(\leftarrow\) 0
            \State i \(\leftarrow\) size(n) - 1
            \While{i \(>\) 0}
                \State number \(\leftarrow\) number + \(n_i\) * \(base^{i-1}\)
                \State i \(\leftarrow\) i - 1
            \EndWhile
            \State baseNToDecimal \(\leftarrow\) number
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\emph{decimalToBaseN}: \emph{Integer} \(\rightarrow\) \emph{char*},
converts the specified integer represented in base 10 into a corresponding integer (char*) in base K.
\ref{algo:basenintegerlist-decimal-to-base} is the corresponding algorithm.

\emph{Principle}
\begin{itemize}
    \item Compute the size of the char
    \item Create the char
    \item Compute the number in base K using division by K.
\end{itemize}

\begin{algorithm}[H]
    \label{algo:basenintegerlist-decimal-to-base}
    \caption{decimalToBaseN algorithm}

    \begin{algorithmic}
        \Function{decimalToBaseN}{n : integer, base : integer} : char*
            \State sizeOfString \(\leftarrow\) 2 // EndOfString character and a bit.
            \State k \(\leftarrow\) base
            \While{number \(>\) k}
                \State k \(\leftarrow\) base * k;
                \State sizeOfString = sizeOfString + 1;
            \EndWhile
            \State string \(\leftarrow\) createString(sizeOfString)
            \State i \(\leftarrow\) sizeOfString - 2 // \(Character_{i-1}\) is reserved for EndOfString character.
            \Repeat
                \State \(string_{i} \leftarrow \) convertToCharacter(n mod base)
                \State n \(\leftarrow\) n / base
                \State i \(\leftarrow\) i - 1;
            \Until{i \(>=\) 0}
            \State decimalToBaseN \(\leftarrow\) string
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
    \label{algo:basenintegerlist-convert-base-to-binary}
    \caption{convertBaseToBinary algorithm}

    \begin{algorithmic}
        \Function{convertBaseToBinary}{n : char*, base : integer} : char*
            \State convertBaseToBinary \(\leftarrow\) decimalToBaseN(baseNToDecimal(n), 2)
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
    \label{algo:basenintegerlist-convert-binary-to-base}
    \caption{convertBinaryToBase algorithm}

    \begin{algorithmic}
        \Function{convertBinaryToBase}{n : char*, base : integer} : char*
            \State convertBinaryToBase \(\leftarrow\) decimalToBaseN(baseNToDecimal(n), base)
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\section{BaseNIntegerListOfList}

\emph{baseNToDecimal}: \emph{Integer} \(\rightarrow\) \emph{BaseNIntegerListOfList},
creates a BaseNIntegerListOfList for storing list of integers in base N (N being the specified integer, first parameter).
\ref{algo:basenintegerlistoflist-create-bucket-list} is the corresponding algorithm.

\begin{algorithm}[H]
    \label{algo:basenintegerlistoflist-create-bucket-list}
    \caption{createBucketList algorithm}

    \begin{algorithmic}
        \Function{createBucketList}{base : Integer} : BaseNIntegerListOfList

            \State bucketList \(\leftarrow \) create(BaseNIntegerListOfList)
            \State base(bucketList) \(\leftarrow \) base
            \State createBucketList \(\leftarrow \) bucketList

        \EndFunction
    \end{algorithmic}
\end{algorithm}
\end{algorithm}

\section{Radix sort}

…

\chapter{Optimizations}

…

\chapter{Summary / conclusion}

…

%##################### Bibliography ########################

\bibpunct{[}{]}{,}{a}{}{;}
\bibliographystyle{plainnat}
\bibliography{bibliography}{}

\end{document}

