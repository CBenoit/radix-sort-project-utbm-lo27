\documentclass[book, nodocumentinfo]{upmethodology-document}

%% The TeX code is entering with UTF8
%% character encoding (Linux and MacOS standards)
\usepackage[utf8]{inputenc}
%% For algorithms
\usepackage[chapter]{algorithm}
\usepackage{algpseudocode}
%% For bibtex
\usepackage{natbib}

\setfrontcover{classic}

\declaredocument{Report about Radix Sort LO27 Project}{Report about Radix Sort LO27 Project for the UTBM}{LO27-A2015}
\setpublisher{University of Technology of Belfort-Montbéliard}

\incversion{\makedate{7}{11}{2015}}{Initial version.}{\upmpublic}

\addauthorvalidator*[benoit.cortier@utbm.fr]{Benoît}{CORTIER}{Author}
\addauthorvalidator*[jerome.boulmier@utbm.fr]{Jérôme}{BOULMIER}{Author}

\setdockeywords{\LaTeX, Radix Sort, Sorting, Algorithm, LO27, Programming}

\setdocabstract{}

\makeatletter
\let\VERversion\upm@package@version@ver
\let\VERfmt\upm@package@fmt@ver
\let\VERdoc\upm@package@doc@ver
\let\VERfp\upm@package@fp@ver
\let\VERbp\upm@package@bp@ver
\let\VERext\upm@package@ext@ver
\let\VERtask\upm@package@task@ver
\let\VERdocclazz\upm@package@docclazz@ver
\let\VERcode\upm@package@code@ver
\makeatother

\setcopyrighter{Benoît CORTIER \& Jérôme BOULMIER}
\setprintingaddress{France}

% Espace insécable (le caractère ~ se traduit par un espace insécable).
\DeclareUnicodeCharacter{00A0}{~}
% Sur un clavier bépo, on a un accès direct au ×, ≥ et ≤
\DeclareUnicodeCharacter{00D7}{\times}
\DeclareUnicodeCharacter{2265}{\geq}
\DeclareUnicodeCharacter{2264}{\geq}

\begin{document}

\chapter{Introduction}

…

\tableofcontents

\listofalgorithms

\chapter{Objectives and problem statements}

…

\chapter{Data structures}

…

\section{BaseNIntegerList}

The type \emph{BaseNIntegerList} represents a list of base-N integers.
This list will be implemented using a doubly linked-list.

\begin{table}[h]
    \centering
    \label{tab:basenintegerlist-struct}

    \begin{tabular}{|l|c|}
        \hline
        BaseNIntegerElement* & head \\
        \hline
        BaseNIntegerElement* & tail \\
        \hline
        int & base \\
        \hline
        int & size \\
        \hline
    \end{tabular}

    \caption{BaseNIntegerList structure}
\end{table}

\begin{itemize}
    \item \emph{head}: pointer to the first element of the list.
    \item \emph{tail}: pointer to the last element of the list.
    \item \emph{base}: an integer between 2 and 16.
    \item \emph{size}: the current number of elements in the list.
\end{itemize}

\subsection{BaseNIntegerElement}

\begin{table}[h]
    \centering
    \label{tab:basenintegerelement-struct}

    \begin{tabular}{|l|c|}
        \hline
        BaseNIntegerElement* & prev \\
        \hline
        BaseNIntegerElement* & next \\
        \hline
        char* & value \\
        \hline
    \end{tabular}

    \caption{BaseNIntegerElement structure}
\end{table}

\section{BaseNIntegerListOfList}

…

\chapter{Algorithms}

…

\section{BaseNIntegerList}

\emph{createIntegerList}: \emph{Integer} \(\rightarrow\) \emph{BaseNIntegerList},
    create a new empty \emph{BaseNIntegerList} for storing integers in the specified base.
    \ref{algo:basenintegerlist-create-integer-list} is the corresponding algorithm.

\begin{algorithm}[H]
    \label{algo:basenintegerlist-create-integer-list}
    \caption{createIntegerList algorithm}

    \begin{algorithmic}
        \Function{createIntegerList}{base : Integer} : BaseNIntegerList
            \State \(l \leftarrow\) create(BaseNIntegerList)
            \State head(\(l\)) \(\leftarrow\) undefined
            \State tail(\(l\)) \(\leftarrow\) undefined
            \State base(\(l\)) \(\leftarrow\) base
            \State size(\(l\)) \(\leftarrow 0\)
            \State createIntegerList \(\leftarrow l\)
        \EndFunction
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{isEmpty}: \emph{BaseNIntegerList} \(\rightarrow\) \emph{Boolean},
returns true if the specified list is empty, false otherwise.
\ref{algo:basenintegerlist-is-empty} is the corresponding algorithm.

\begin{algorithm}[H]
    \label{algo:basenintegerlist-is-empty}
    \caption{isEmpty algorithm}

    \begin{algorithmic}
        \Function{isEmpty}{\(l\) : BaseNIntegerList} : Boolean
            \If{head(\(l\)) = undefined}
                \State isEmpty \(\leftarrow\) TRUE
            \Else
                \State isEmpty \(\leftarrow\) FALSE
            \EndIf
        \EndFunction
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{insertHead}: \emph{BaseNIntegerList} \(\times\) \emph{char*} \(\rightarrow\) \emph{BaseNIntegerList},
adds the specified integer (\emph{char*}, represented in the considered base) at the beginning
of the specified list.
\ref{algo:basenintegerlist-insert-head} is the corresponding algorithm.

\emph{Principle}
\begin{itemize}
    \item create a new element.
    \item link it and the rest of the list to each other if any.
    \item make it the head of the list.
    \item increase size of the list accordingly.
\end{itemize}

\begin{algorithm}[H]
    \label{algo:basenintegerlist-insert-head}
    \caption{insertHead algorithm}

    \begin{algorithmic}
        \Function{insertHead}{\(l\) : BaseNIntegerList, value : char*} : BaseNIntegerList
            \State new\_el \(\leftarrow\) create(BaseNIntegerElement)

            \State value(new\_el) \(\leftarrow\) value
            \State prev(new\_el) \(\leftarrow\) undefined

            \If{isEmpty(\(l\))}
                \State next(new\_el) \(\leftarrow\) undefined
                \State tail(\(l\)) \(\leftarrow\) new\_el
            \Else
                \State next(new\_el) \(\leftarrow\) head(\(l\))
                \State prev(head(\(l\))) \(\leftarrow\) new\_el
            \EndIf

            \State head(\(l\)) \(\leftarrow\) new\_el
            \State size(\(l\)) \(\leftarrow\) size(\(l\)) + 1

            \State insertHead \(\leftarrow l\)
        \EndFunction
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{insertTail}: \emph{BaseNIntegerList} \(\times\) \emph{char*} \(\rightarrow\) \emph{BaseNIntegerList},
adds the specified integer (\emph{char*}, represented in the considered base) at the end
of the specified list.
\ref{algo:basenintegerlist-insert-tail} is the corresponding algorithm.

\emph{Principle}
\begin{itemize}
    \item create a new element.
    \item link it and the tail of the list to each other if any.
    \item make it the tail of the list.
    \item increase size of the list accordingly.
\end{itemize}

\begin{algorithm}[H]
    \label{algo:basenintegerlist-insert-tail}
    \caption{insertTail algorithm}

    \begin{algorithmic}
        \Function{insertTail}{\(l\) : BaseNIntegerList, value : char*} : BaseNIntegerList
            \State new\_el \(\leftarrow\) create(BaseNIntegerElement)

            \State value(new\_el) \(\leftarrow\) value
            \State next(new\_el) \(\leftarrow\) undefined

            \If{isEmpty(\(l\))}
                \State prev(new\_el) \(\leftarrow\) undefined
                \State head(\(l\)) \(\leftarrow\) new\_el
            \Else
                \State prev(new\_el) \(\leftarrow\) tail(\(l\))
                \State next(tail(\(l\))) \(\leftarrow\) new\_el
            \EndIf

            \State tail(\(l\)) \(\leftarrow\) new\_el
            \State size(\(l\)) \(\leftarrow\) size(\(l\)) + 1

            \State insertTail \(\leftarrow l\)
        \EndFunction
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{removeHead}: \emph{BaseNIntegerList} \(\rightarrow\) \emph{BaseNIntegerList},
removes the first element of the specified list.
\ref{algo:basenintegerlist-remove-head} is the corresponding algorithm.

\emph{Principle}
\begin{itemize}
    \item makes the second element the head of the list if any.
    \item free the first element from the memory.
    \item decrease size of the list accordingly.
\end{itemize}

\begin{algorithm}[H]
    \label{algo:basenintegerlist-remove-head}
    \caption{removeHead algorithm}

    \begin{algorithmic}
        \Function{removeHead}{\(l\) : BaseNIntegerList} : BaseNIntegerList
            \If{isEmpty(l)}
                \State removeHead \(\leftarrow l\)
            \EndIf

            \State BaseNIntegerElement old\_el \(\leftarrow\) head(l)
            \State head(l) \(\leftarrow\) next(head(l))
            \State free(old\_el)
            \State size(\(l\)) \(\leftarrow\) size(\(l\)) - 1

            \If{isEmpty(l)}
                \State tail(l) \(\leftarrow\) undefined
            \Else
                \State prev(head(l)) \(\leftarrow\) undefined
            \EndIf

            \State removeHead \(\leftarrow l\)
        \EndFunction
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{removeTail}: \emph{BaseNIntegerList} \(\rightarrow\) \emph{BaseNIntegerList},
removes the last element of the specified list.
\ref{algo:basenintegerlist-remove-tail} is the corresponding algorithm.

\emph{Principle}
\begin{itemize}
    \item makes element n-1 the tail of the list if n \(>\) 1.
    \item free element n from the memory.
    \item decrease size of the list accordingly.
\end{itemize}

\begin{algorithm}[H]
    \label{algo:basenintegerlist-remove-tail}
    \caption{removeTail algorithm}

    \begin{algorithmic}
        \Function{removeTail}{\(l\) : BaseNIntegerList} : BaseNIntegerList
            \If{isEmpty(l)}
                \State removeTail \(\leftarrow l\)
            \EndIf

            \State BaseNIntegerElement old\_el \(\leftarrow\) tail(l)
            \State tail(l) \(\leftarrow\) prev(tail(l))
            \State free(old\_el)
            \State size(\(l\)) \(\leftarrow\) size(\(l\)) - 1

            \If{tail(l) = undefined}
                \State head(l) \(\leftarrow\) undefined
            \Else
                \State next(tail(l)) \(\leftarrow\) undefined
            \EndIf

            \State removeTail \(\leftarrow l\)
        \EndFunction
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{deleteBaseNIntegerElement}: \emph{BaseNIntegerElement} \(\rightarrow\) \(\emptyset\),
free from the memory the specified BaseNIntegerElement.
\ref{algo:basenintegerlist-delete-basen-integer-element} is the corresponding algorithm.

\begin{algorithm}[H]
    \label{algo:basenintegerlist-delete-basen-integer-element}
    \caption{deleteBaseNIntegerElement algorithm}

    \begin{algorithmic}
        \Function{deleteBaseNIntegerElement}{\(el\) : BaseNIntegerElement} : \(\emptyset\)
            \State free(value(el))
            \State free(el)
        \EndFunction
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{deleteIntegerList}: \emph{BaseNIntegerList} \(\rightarrow\) \(\emptyset\),
clears and deletes the specified BaseNIntegerList.
\ref{algo:basenintegerlist-delete-integer-list} is the corresponding algorithm.

\emph{Principle}: traverse the entire list and free each element.

\begin{algorithm}[H]
    \label{algo:basenintegerlist-delete-integer-list}
    \caption{deleteIntegerList algorithm}

    \begin{algorithmic}
        \Function{deleteIntegerList}{\(l\) : BaseNIntegerList} : \(\emptyset\)
            \If{!isEmpty(l)}
                \State BaseNIntegerElement old\_el \(\leftarrow\) head(l)
                \State BaseNIntegerElement next\_el

                \While{next(old\_el) \(\neq\) undefined}
                    \State next\_el \(\leftarrow\) next(old\_el)
                    \State deleteBaseNIntegerElement(old\_el)
                    \State old\_el \(\leftarrow\) next\_el
                \EndWhile

                \State deleteBaseNIntegerElement(old\_el)
            \EndIf
        \EndFunction
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{sumBaseNIntegers}: \emph{char*} \(\times\) \emph{char*} \(\times\) \emph{Integer} \(\rightarrow\) \emph{char*},
sums two integers defined in the given base (without any conversion).
\ref{algo:basenintegerlist-sum-basen-integers} is the corresponding algorithm.

\emph{Principle}: …

\begin{algorithm}[H]
    \label{algo:basenintegerlist-sum-basen-integers}
    \caption{sumBaseNIntegers algorithm}

    \begin{algorithmic}
        \Function{sumBaseNIntegers}{\(a\) : char*, \(b\) : char*, base : \emph{Integer}} : char*
            \State Integer sizeA \(\leftarrow\) size(a)
            \State Integer sizeB \(\leftarrow\) size(b)
            \State Integer sizeC \(\leftarrow\) max(sizeA, sizeB)
            \State char* result \(\leftarrow\) createString(sizeC)

            \State Integer remainder \(\leftarrow\) 0
            \State Integer i \(\leftarrow\) 0
            \While{i \(<\) sizeA and i \(<\) sizeB}
                \State \(result_i \leftarrow a_i\) + \(b_i\) + remainder
                \State remainder \(\leftarrow result_i\) / base
                \State \(result_i \leftarrow result_i\) mod base

                \State i \(\leftarrow\) i + 1
            \EndWhile

            \While{i \(<\) sizeA}
                \State \(result_i \leftarrow a_i\) + remainder
                \State remainder \(\leftarrow result_i\) / base
                \State \(result_i \leftarrow result_i\) mod base

                \State i \(\leftarrow\) i + 1
            \EndWhile

            \While{i \(<\) sizeB}
                \State \(result_i \leftarrow b_i\) + remainder
                \State remainder \(\leftarrow result_i\) / base
                \State \(result_i \leftarrow result_i\) mod base

                \State i \(\leftarrow\) i + 1
            \EndWhile

            \If{remainder \(>\) 0}
                \State result \(\leftarrow\) realloc(result, (sizeC + 1) * size(char))
                \State \(result_{sizeC} \leftarrow\) remainder
            \EndIf

            \State sumBinary \(\leftarrow\) result
        \EndFunction
    \end{algorithmic}
\end{algorithm}

Assumption : \emph{size} is a function that returns the string's size.
\emph{max} is a function that returns the maximum value between the given two.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{sumIntegerList}: \emph{BaseNIntegerList} \(\rightarrow\) char*,
sums all the integers defined in the specified list using the binary addition and returns
the corresponding results as an integer (\emph{char*}) represented in the base of the list.
\ref{algo:basenintegerlist-sum-integer-list} is the corresponding algorithm.

\emph{Principle}: …

\begin{algorithm}[H]
    \label{algo:basenintegerlist-sum-integer-list}
    \caption{sumIntegerList algorithm}

    \begin{algorithmic}
        \Function{sumIntegerList}{\(l\) : BaseNIntegerList} : char*
            \State char* sum \(\leftarrow\) createString(0)
            \State \(sum_0\) \(\leftarrow\) 0

            \State BaseNIntegerElement el \(\leftarrow\) head(l)
            \While{el \(\neq\) undefined}
                \State sum \(\leftarrow\) sumBaseNIntegers(sum, value(el), base(l))
                \State el \(\leftarrow\) next(el)
            \EndWhile

            \State sumIntegerList \(\leftarrow\) sum
        \EndFunction
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[H]
	\label{algo:basenintegerlist-basen-to-decimal}
	\caption{baseNToDecimal algorithm}

	\begin{algorithmic}
		\Function{baseNToDecimal}{n : char*, base : integer} : integer
			\State number = 0
			\State i = size(n)
			\While{i \(>\) 0}
				\State number \(\leftarrow\) number + \(n_i\) * \(base^{i-1}\)
				\State i = i - 1
			\EndWhile
			\State baseNToDecimal \(\leftarrow\) number
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
	\label{algo:basenintegerlist-decimalToBinary}
	\caption{decimalToBinary algorithm}

	\begin{algorithmic}
		\Function{decimalToBinary}{n : integer} : char*
			\State sizeOfString = 1
			\While{n \(> 2^{sizeOfString}\)}
				\State sizeOfString = sizeOfString + 1
			\EndWhile
			\State string \(\leftarrow\) createString(sizeOfString)
			\State i \(\leftarrow\) sizeOfString
			\Repeat
				\State \(string_{i} \leftarrow \) n mod 2
				\State n \(\leftarrow\) n / 2
			\Until{n \(\neq\) 0}
			\State decimalToBinary \(\leftarrow\) string
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\section{BaseNIntegerListOfList}

\begin{algorithm}[H]
	\label{algo:basenintegerlistoflist-create-bucket-list}
	\caption{createBucketList algorithm}

	\begin{algorithmic}
		\Function{createBucketList}{base : Integer} : BaseNIntegerListOfList

		\State bucketList \(\leftarrow \) create(BaseNIntegerListOfList)
		\State base(bucketList) \(\leftarrow \) base
		\State createBucketList \(\leftarrow \) bucketList

		\EndFunction
	\end{algorithmic}
\end{algorithm}

\section{Radix sort}

…

\chapter{Optimizations}

…

\chapter{Summary / conclusion}

…

%##################### Bibliography ########################

\bibpunct{[}{]}{,}{a}{}{;}
\bibliographystyle{plainnat}
\bibliography{bibliography}{}

\end{document}

